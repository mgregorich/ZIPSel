---
title: 'Example of data generation'
author:
  - name: "Mariella Gregorich"
    affiliation: "Medical University of Vienna, Center for Medical Data Science"
date: last-modified
categories: [2023, ZIPSel, variable selection, R]
description: "Classification: confidential"
editor: visual
theme: cosmo
toc: true  
number-sections: true
colorlinks: true
highlight-style: pygments
format:
  html: 
    code-fold: true
    code-tools: true
    html-math-method: katex
    self-contained: true
---

# Preliminaries

```{r}
rm(list=ls())
# Packages
pacman::p_load(ggplot2, parallel, future.apply, stringr,
               dplyr, tidyr, Matrix, patchwork, forcats, gt,
               glmnet, MASS, simdata, reshape2)
set.seed(666)

# R files
# source(here::here("src", "setup.R"))
source(here::here("src","functions_aux.R"))
source(here::here("src","functions_sim.R"))

# Parameter
ngroups = 4
nlams = 10
nR = 5
ncv = 10

# Load & save setup
setup <- readRDS(here::here("src", "scenario_setup.rds"))
scenarios <- setup[[1]]
sim_design <- setup[[2]]

scn_nr = 133 # 183, 237, 291
scn <- scenarios[scn_nr,]
dsgn <- sim_design[[scenarios[scn_nr,]$dsgn]]
```

An explanation of the parameters in the scenario configuration is given below.

| Variable                                                    | Abbreviation      | Description                                                                                                                                                                                       |
|------------------|------------------|-----------------------------------|
| Sample size                                                 | n                 | Number of samples within each dataset                                                                                                                                                             |
| Number of candidate predictors                              | p                 | Number of predictors available to the data analyst                                                                                                                                                |
| Scenario                                                    | \-                | Either A (all variables of group 1 are predictors) or B (5 predictors of each group are the true predictors)                                                                                      |
| Maxmimum regression coefficient                             | beta_max          | Magnitude of regression coefficients is linearly decreasing for the continuous component and randomly permuted for the binary component.                                                          |
| Dependence between U and D component for outcome generation | UDdepen and a     | UDdepen can be U=2D, U=D or U and accordingly a is specified                                                                                                                                      |
| Residual variance                                           | epslvl and epsstd | The level of residual variance can be none, moderate and high and accordingly epsstd is specified, Intention ist to receive R2 of (1, 0.6, 0.3) but sampling zeros are not factored in currently. |
| Proportion of zero-inflation                                | propzi            | Proportion of total zero-inflation (structural and sampling) = (0.75, 0.25)                                                                                                                       |
| Structural zero                                             | struczero         | Proportion of structural zero from the total proportion. Either 33% or 66%. Sampling zero is reversed.                                                                                            |
| Reverse distribution of zero-inflation                      | revzi             | If false, zero-inflation is linearly increasing per group e.g. Variable 1 has 0 % such that Variable 50 has 75%. If true the reverse holds.                                                       |

Since only one scenario of the 432 defined scenarios can be shown here, the parameter configuration for this scenario is listed as follows.

```{r}
#| tbl-cap: "Parameter specifications for the selected scenario"
data.frame("Parameter"=rownames(t(scn[,1:13])), "Value"=t(scn[,1:13])) %>%
  rename("Value"=paste0("X", scn_nr)) %>% 
  gt()
```

# Data generation

## Simulated data for the outcome generation

In this section, we will elaborate on the data simulation in order to generate the outcome $y$. Hence, the inclusion of the sampling zeros will not be discussed here but in the next section.

```{r}
# Data generation
data_sim <- data_generation(dsgn = dsgn, OGM = scn$OGM, n = scn$n,
                            p=scn$p, beta_max = scn$beta_max,
                            a = scn$a, epsstd = scn$epsstd, xmean= scn$xmean, xstd = scn$xstd,
                            propzi = scn$propzi, revzi = scn$revzi, 
                            struczero = scn$struczero)
# Data object for models
data.obj <- generate_dataobj(y = data_sim$data_ana$y, 
                             z = data_sim$data_ana$X,
                             clinical = NULL, logtransform = FALSE)
true_beta <- data_sim$data_coef
checkR2 <- round(1-(var(data_sim$data_gen$eps)/var(data_sim$data_gen$y)),2)
print(paste0("Computed true R2 based on variance of y and residual variance =", checkR2))
```

In the Figure below in Panel (A), the original peptide intensity data which follows a multivariate log-normal distribution is displayed. The incorporation of structural zeros are performed on the log-normal distributed data by the element-wise multiplication of the binary data matrix $D_{struc}$, where each column is distributed according to $d_j\sim B(1,p_j)$ with $p_j$ being the probability of structural zero-inflation.

The outcome is generated according to $$
y = a X_{struc} \beta_X + (1-a) D_{struc} \beta_D + \epsilon
$$ where $a$ is a parameter that controls the influence of the two components on the outcome vector $y$. For the generation of the outcome $y$, we will log-transform the log-normally distributed peptide data, shift it by its minimum value and set the zero values to the mean value of the intensities \> 0 such that we obtain the data referred to as $X_{struc}$ and depicted in (B1).

```{r}
#| fig-cap: "Distribution of prepared peptide intensities excluding zero values"
p1 <- data.frame("intensity" = c(unlist(data_sim$data_gen$X_org))) %>% 
  ggplot(aes(x = intensity)) + 
  geom_histogram(col = "black", fill = "grey89", bins = 30) + 
  scale_x_continuous("Intensity") +
  scale_y_continuous("Count") +
  theme_light() + 
  theme(plot.title = element_text(hjust=0.5)) +
  ggtitle("Simulated peptide intensity with structural zeros")
p2 <- data.frame("intensity" = c(data_sim$data_gen$X_struc)) %>% 
  ggplot(aes(x = intensity)) + 
  geom_histogram(col = "black", fill = "grey89", bins = 30) +
  scale_x_continuous("Intensity") +
  scale_y_continuous("Count") +
  theme_light() + 
  theme(plot.title = element_text(hjust=0.5)) +
  ggtitle("Transformed data X")

p3 <- data.frame("intensity" = to_factor(c(data_sim$data_gen$D_struc))) %>% 
  ggplot(aes(x = intensity)) + 
  geom_bar(col = "black", fill = "grey89") + 
  scale_x_discrete("Intensity > 0") +
  scale_y_continuous("Count") +
  theme_light()+
  theme(plot.title = element_text(hjust=0.5)) +
  ggtitle("Binary component D")

p_all <- (p1 ) / ( p2 + p3 ) + plot_annotation(tag_levels = list(c('(A)', '(B1)', '(B2)')))
p_all
```

The regression coefficients are according to the selected Scenario:

-   **OGM A**: Only peptides in group 1 have an effect on the outcome variable $y$. The effect is linearly decreasing for the true predictors in the continuous component $X_{struc}$, while it is permuted for the true predictors in the binary component $D_{struc}$, otherwise it is 0.
-   **OGM B**: In each group, 5 peptides which are spaced equally with regard to the index are true predictors. The effect again linearly decreases for the true predictors in the continuous component $X_{struc}$ and is randomly permuted for the true predictors in the binary component $D_{struc}$, otherwise 0.

```{r}
scn_A <- scenarios[50,]
data_simA <- data_generation(dsgn = dsgn, OGM = scn_A $OGM, n = scn_A $n,
                            p=scn_A $p, beta_max = scn_A $beta_max,
                            a = scn_A $a, epsstd = scn_A $epsstd, xmean= scn_A $xmean, xstd = scn_A $xstd,
                            propzi = scn_A $propzi, revzi = scn_A $revzi, 
                            struczero = scn_A $struczero)
true_beta_A <- data_simA$data_coef %>%
  mutate(OGM = "OGM = A",
         ind = as.numeric(str_remove_all(var, "V")),
         group = rep(c("Group 1", "Group 2", "Group 3", "Group 4"), each=scn$p/ngroups))
scn_B <- scenarios[250,]
data_simB <- data_generation(dsgn = dsgn, OGM = scn_B$OGM, n = scn_B$n,
                            p=scn_B$p, beta_max = scn_B$beta_max,
                            a = scn_B$a, epsstd = scn_B$epsstd, xmean= scn_B$xmean, xstd = scn_B$xstd,
                            propzi = scn_B$propzi, revzi = scn_B$revzi, 
                            struczero = scn_B$struczero)
true_beta_B <- data_simB$data_coef %>%
  mutate(OGM = "OGM = B",
         ind = as.numeric(str_remove_all(var, "V")),
         group = rep(c("Group 1", "Group 2", "Group 3", "Group 4"), each=scn$p/ngroups))
scn_C <- scenarios[450,]
data_simC <- data_generation(dsgn = dsgn, OGM = scn_C$OGM, n = scn_C$n,
                            p=scn_C$p, beta_max = scn_C$beta_max,
                            a = scn_C$a, epsstd = scn_C$epsstd, xmean= scn_C$xmean, xstd = scn_C$xstd,
                            propzi = scn_C$propzi, revzi = scn_C$revzi, 
                            struczero = scn_C$struczero)
true_beta_C <- data_simC$data_coef %>%
  mutate(OGM = "OGM = C",
         ind = as.numeric(str_remove_all(var, "V")),
         group = rep(c("Group 1", "Group 2", "Group 3", "Group 4"), each=scn$p/ngroups))

true_beta_all <- rbind(true_beta_A, true_beta_B, true_beta_C)
true_beta_all %>%
  dplyr::select(var, ind, group, OGM, beta_X, beta_D) %>%
  pivot_longer(cols=c(beta_X, beta_D), names_to = "Effect", values_to = "coef") %>%
  ggplot(aes(x=ind, y=coef, group=Effect, linetype=Effect, shape=Effect, color=Effect)) +
  {if(scn$OGM=="B")geom_point()} +
  geom_line() +
  facet_grid(OGM~group, scales = "free_x") +
  scale_x_continuous("Predictor index") +
  scale_y_continuous("Coefficient") +
  scale_linetype_manual(values = c(1,2)) +
  scale_color_manual(values=c("darkblue", "darkred")) +
  theme_bw() +
  theme(legend.position = "top", text = element_text(size=14))
ggsave(file = here::here("output", "auxiliary","fig_coef_pops.tiff"),
       width = 2.25*100, height = 2*100, units = "mm", dpi = 350, compression = "lzw")
```

```{r}
#| fig-cap: "Magnitude of true regression coefficients grouped by continuous component U and binary component D"
true_beta %>%
  dplyr::select(var, beta_X, beta_D) %>%
  mutate(ind = as.numeric(str_remove_all(var, "V")),
         group = rep(c("G1", "G2", "G3", "G4"), each=scn$p/ngroups)) %>%
  pivot_longer(cols=c(beta_X, beta_D), names_to = "Effect", values_to = "coef") %>%
  ggplot(aes(x=ind, y=coef, group=Effect, linetype=Effect, shape=Effect)) +
  {if(scn$OGM=="B")geom_point()} +
  geom_line() +
  facet_grid(~group, scales = "free_x") +
  scale_x_continuous("Variable index") +
  scale_y_continuous("Coefficient") +
  scale_linetype_manual(values = c(2,1)) +
  theme_bw() +
  theme(legend.position = "top")

```

The outcome then follow the following distribution:

```{r}
#| fig.width: 8
#| fig.height: 4
#| #| fig-cap: "Distribution of the outcome variable y. Extreme values were truncated by the 1st and 99th quantile."
hist(data_sim$data_ana$y, main="Distribution of the outcome variable y", xlab = "Value")
```

## Hub correlation structure

The following hub correlation structure was defined for the four groups.

```{r}
#| fig-cap: "Specified correlation structure within and in-between the four groups"
  rhomat <- rbind(c(.8,.2), c(.8,.2), c(.8,.2), c(.2,.1))  # correlation ranges in each group
hub_cormat <- simcor.H(k = ngroups, size = rep(scn$p/ngroups,ngroups),
                       rho = rhomat, power = 1, epsilon = 0.075, eidim = 2)
if(!matrixcalc::is.positive.definite(hub_cormat)) hub_cormat <- nearPD(hub_cormat, base.matrix = TRUE, 
                                                                       keepDiag = TRUE)$mat
melted_cormat <- melt(hub_cormat)

pc1 <- ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="") +
  scale_x_continuous("Candidate predictors", expand=c(0,0)) +
  scale_y_continuous("Candidate predictors", expand=c(0,0)) +
  theme_bw() 

melted_Xstruc <- melt(cor(data_sim$data_gen$X_struc)) %>%
  mutate(Var1 = as.numeric(str_remove_all(Var1, "V")),
         Var2 = as.numeric(str_remove_all(Var2, "V")))
pc2 <- ggplot(data = melted_Xstruc, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="") +
  theme_bw() 
pc1 + pc2 + plot_layout(guides = "collect") & theme(legend.position = 'bottom') 
ggsave(file = here::here("output", "auxiliary","fig_corr_lognormal.tiff"), plot=pc1,
       width = 1.25*100, height = 1*100, units = "mm", dpi = 350, compression = "lzw")
```

```{r}
data_cor <- cor(data_sim$data_ana$X)
melted_cormat <- reshape2::melt(data_cor) %>%
  data.frame() %>%
  mutate(value=as.numeric(value)) 

ggplot(data=melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="") +
  theme_bw() 
```

## Data preparation for data analyst

For the data analyst, the process of sampling zero is also relevant. Thus, the data that the data analyst receives is not identical to the data employed to generate the outcome. See the Figure below.

```{r}
#| fig-cap: "Comparison between simulatde peptide matrix X with both, structural and sampling zeros included (left) and the binary matrix D"

X_str <- data_sim$data_gen$X_struc
X_sam <- as.matrix(data_sim$data_ana$X)
D_str <- data_sim$data_gen$D_struc
D_samp <- data_sim$data_gen$D_samp

melt_Xstr <- melt(X_str)
melt_Xsam <- melt(X_sam)
melt_Dstr <- melt(D_str)
melt_Dsamp <- melt(D_samp)

melt_Dstr$value_rev <- (melt_Dstr$value==0)*1
melt_Dsamp$value_rev <- (melt_Dsamp$value==0)*1
uplim <- plyr::round_any(max(X_sam), 5, f=ceiling)


p_Xsam <- ggplot(data = melt_Xsam, aes(x=Var2, y=Var1, fill=value)) +
 geom_tile()+
 scale_fill_gradient2(low = "white", high = "blue",
   limit = c(0,uplim), name="") +
  theme_bw()+ 
  ggtitle("X with structural & sampling zeros") +
 theme(axis.text = element_blank(), axis.title = element_blank(), axis.ticks = element_blank(),
       legend.position = "top", plot.title = element_text(hjust = 0.5, size=10))

p_Dstrc <- ggplot(data = melt_Dstr, aes(x=Var2, y=Var1, fill=value)) +
 geom_tile()+
 scale_fill_gradient2(low = "white", high = "red",
   limit = c(0,1), name="") +
  theme_bw()+ 
  ggtitle("D matrix of structural zeros") +
 theme(axis.text = element_blank(), axis.title = element_blank(), axis.ticks = element_blank(),
       legend.position = "top", plot.title = element_text(hjust = 0.5, size=10))

p_Dsamp <- ggplot(data = melt_Dsamp, aes(x=Var2, y=Var1, fill=value)) +
 geom_tile()+
 scale_fill_gradient2(low = "white", high = "red",
   limit = c(0,1), name="") +
  theme_bw()+ 
  ggtitle("D matrix of structural zeros") +
 theme(axis.text = element_blank(), axis.title = element_blank(), axis.ticks = element_blank(),
       legend.position = "top", plot.title = element_text(hjust = 0.5, size=10))

 p_Xsam + p_Dstrc + p_Dsamp + plot_layout(guides = "collect") & theme(legend.position = 'bottom') 
```

The number of values that fall victim to being set to zero according to one of the two processes varies depending on the proportion of structural and sampling zeros indicated (see Figure below).

```{r}
#| fig-cap: "Proportion of zero-inflation in the predictors grouped by source of zero-inflation and for each of the four groups"
true_beta %>%
  data.frame() %>%
  mutate(ind = as.numeric(str_remove_all(var, "V")),
         group = rep(c("Group 1", "Group 2", "Group 3", "Group 4"), each=scn$p/ngroups)) %>%
  pivot_longer(cols=c(propzi, struczi, samplzi), names_to = "ZI", values_to = "prop") %>%
  mutate(ZI = fct_recode(ZI, "total"="propzi", "sampling"="samplzi", "structural"="struczi")) %>%
  ggplot(aes(x=ind, y=prop, group=ZI, col=ZI)) +
  geom_line() +
  facet_grid(~group, scales = "free_x") +
  scale_x_continuous("Variable index") +
  scale_y_continuous("Proportion of zero-inflation") +
  scale_color_discrete("Source of zero-inflation") +
  theme_bw() +
  theme(legend.position = "top")

```

Theoretical distribution of zero-inflation for each of the three OGM settings (A, B, C)

```{r}
propzi_seq_A <- seq(0, 0.75, length.out=50)
df_zi_A <- data.frame("OGM" = "A", "ind"=1:200, "group" = rep(c("Group 1", "Group 2", "Group 3", "Group 4"),each=50),
                    "propzi"=rep(propzi_seq_A, 4), "struczi"=rep(propzi_seq_A, 4)*(1/3), "samplzi"=rep(propzi_seq_A, 4)*(2/3))
propzi_seq_B <- c(seq(0.75/2, 0.75, length.out=25), seq(0, 0.75/2, length.out=25))
df_zi_B <- data.frame("OGM" = "B", "ind"=1:200, "group" = rep(c("Group 1", "Group 2", "Group 3", "Group 4"),each=50),
                    "propzi"=c(rep(propzi_seq_B, 2), rep(rev(propzi_seq_B), 2))) %>%
  mutate("struczi"=propzi*(1/3), "samplzi"=propzi*(2/3))
propzi_seq_C <- seq(0, 0.75, length.out=50)
df_zi_C <- data.frame("OGM" = "C", "ind"=1:200, "group" = rep(c("Group 1", "Group 2", "Group 3", "Group 4"),each=50),
                    "propzi"=c(rep(propzi_seq_C, 2), rep(rev(propzi_seq_C), 2))) %>%
  mutate("struczi"=propzi*(1/3), "samplzi"=propzi*(2/3))
df_zi <- rbind(df_zi_A, df_zi_B, df_zi_C)


df_zi %>%
  data.frame() %>%
  pivot_longer(cols=c(propzi, struczi, samplzi), names_to = "ZI", values_to = "prop") %>%
  mutate(ZI = fct_recode(ZI, "total"="propzi", "sampling"="samplzi", "structural"="struczi")) %>%
  mutate(OGM=paste0("OGM = ", OGM)) %>%
  ggplot(aes(x=ind, y=prop, group=ZI, col=ZI, linetype=ZI)) +
  geom_line() +
  facet_grid(OGM~group, scales = "free_x") +
  scale_x_continuous("Predictor index") +
  scale_y_continuous("Proportion of zero-inflation", limits = c(0,1)) +
  scale_color_manual("Source of zero-inflation", values=c("black", "grey25", "grey55")) +
  scale_linetype_discrete("Source of zero-inflation") +
  theme_bw() +
  theme(legend.position = "top")
ggsave(file = here::here("output", "auxiliary","fig_zi_pops.tiff"),
       width = 1.75*100, height = 1.5*100, units = "mm", dpi = 350, compression = "lzw")
```

Another binary matrix, $D_{sam}$, determines which values are subject to sampling zeros. Values below specific quantiles of the log-normal distributed peptide intensities are set to zero based on proportions of sampling zero-inflation specified for each peptide individually, as depicted in the Figure above. The data analyst's final data set is obtained by element-wise multiplication of $D_{struc}$ and $D_{sam}$ with $X_{struc}$, which is shown in Panel (B1) in the previous section. Multiplication by $D_{struc}$ is necessary since zeros values were transformed to the mean in $X_{struc}$. The multiplication with $D_{sam}$ incorporates the sampling zeros. Thus, the final data set the data analyst receives has the following distribution:

```{r}
#| fig-cap: "Distribution of simulated peptide intensities that the data analyst receives."
hist(c(data_sim$data_ana$X ))
```

Upon receipt of the data (Panel (A)), the data analyst may adjust the distribution according to their preference by defining the zero values, without knowledge of the source of said zeros. We will examine two methods and illustrate them below.

1)  The conventional approach which designates the zero values as half the minimum of the positive values (Panel (B)).
2)  The distribution can be separated into its continuous component, denoted as $U$, where zero values are determined as the average of the positive values (Panel (C1)), and its binary component, denoted as $D$ (Panel (C2)), where its entries may result from either sampling or structural zero but are unknown to the data analyst.

```{r}
#| fig-cap: "Distribution of prepared peptide intensities excluding zero values"
p1 <- data.frame("intensity" = c(unlist(data_sim$data_gen$data_logn))) %>% 
  ggplot(aes(x = intensity)) + 
  geom_histogram(col = "black", fill = "grey89", bins = 30) +
  scale_x_continuous("Intensity") +
  scale_y_continuous("Count") +
  theme_light() + 
  theme(plot.title = element_text(hjust=0.5)) 
p2 <- data.frame("intensity" = c(data.obj$x)) %>% 
  ggplot(aes(x = intensity)) + 
  geom_histogram(col = "black", fill = "grey89", bins = 30) +
  scale_x_continuous("Intensity") +
  scale_y_continuous("Count") +
  theme_light() + 
  theme(plot.title = element_text(hjust=0.5))
p3 <- data.frame("intensity" = c(data.obj$u)) %>% 
  ggplot(aes(x = intensity)) + 
  geom_histogram(col = "black", fill = "grey89", bins = 30) +
  scale_x_continuous("Intensity") +
  scale_y_continuous("Count") +
  theme_light() + 
  theme(plot.title = element_text(hjust=0.5)) +
  ggtitle("Component variable U")
p4 <- data.frame("intensity" = to_factor(c(data.obj$d))) %>% 
  ggplot(aes(x = intensity)) + 
  geom_bar(col = "black", fill = "grey89") + 
  scale_x_discrete("Intensity > 0") +
  scale_y_continuous("Count") +
  theme_light()+
  theme(plot.title = element_text(hjust=0.5)) +
  ggtitle("Component variable D")

p_all <- (p1 + p2 ) / ( p3 + p4 ) + plot_annotation(tag_levels = list(c('(A)', '(B)','(C1)', '(C2)')))
p_all
ggsave(file = here::here("output", "auxiliary","fig_design_vars_all.tiff"), plot=p_all,
       width = 2.1*100, height = 1.5*100, units = "mm", dpi = 350, compression = "lzw")
```

```{r}
#| fig-cap: "Distribution of prepared peptide intensities excluding zero values"
p1 <- data.frame("intensity" = data_sim$data_gen$data_logn[,1]) %>% 
  ggplot(aes(x = intensity)) + 
  geom_histogram(col = "black", fill = "grey89", bins = 30) +
  scale_x_continuous("Intensity") +
  scale_y_continuous("Count") +
  theme_light() + 
  theme(plot.title = element_text(hjust=0.5)) 
p2 <- data.frame("intensity" = data.obj$x[,1]) %>% 
  ggplot(aes(x = intensity)) + 
  geom_histogram(col = "black", fill = "grey89", bins = 30) +
  scale_x_continuous("Intensity") +
  scale_y_continuous("Count") +
  theme_light() + 
  theme(plot.title = element_text(hjust=0.5))
p3 <- data.frame("intensity" = data.obj$u[,1]) %>% 
  ggplot(aes(x = intensity)) + 
  geom_histogram(col = "black", fill = "grey89", bins = 30) +
  scale_x_continuous("Intensity") +
  scale_y_continuous("Count") +
  theme_light() + 
  theme(plot.title = element_text(hjust=0.5)) +
  ggtitle("Component variable U")
p4 <- data.frame("intensity" = to_factor(data.obj$d[,1])) %>% 
  ggplot(aes(x = intensity)) + 
  geom_bar(col = "black", fill = "grey89") + 
  scale_x_discrete("Intensity > 0") +
  scale_y_continuous("Count") +
  theme_light()+
  theme(plot.title = element_text(hjust=0.5)) +
  ggtitle("Component variable D")

p_all <- (p1 + p2 ) / ( p3 + p4 ) + plot_annotation(tag_levels = list(c('(A)', '(B)','(C1)', '(C2)')))
p_all
ggsave(file = here::here("output", "auxiliary","fig_design_vars_one.tiff"), plot=p_all,
       width = 1.75*100, height = 1.5*100, units = "mm", dpi = 350, compression = "lzw")
```

## Validation data

```{r}
# Generate large validation dataset
data.val <- data_generation(dsgn = dsgn, OGM = scn$OGM, n = 100000,
                            p=scn$p, beta_max = scn$beta_max, 
                            a = scn$a, epsstd = scn$epsstd, xmean = scn$xmean, xstd = scn$xstd,
                            propzi = scn$propzi, revzi = scn$revzi, 
                            struczero = scn$struczero)
data.obj.val <- generate_dataobj(y = data.val$data_ana$y, 
                                 z = data.val$data_ana$X,
                             clinical = NULL, logtransform = FALSE)
```

```{r}
#| fig-cap: "Magnitude of true regression coefficients in validation data grouped by continuous component U and binary component D"
data.val$data_coef %>%
  dplyr::select(var, beta_X, beta_D) %>%
  mutate(ind = as.numeric(str_remove_all(var, "V")),
         group = rep(c("G1", "G2", "G3", "G4"), each=scn$p/ngroups)) %>%
  pivot_longer(cols=c(beta_X, beta_D), names_to = "Effect", values_to = "coef") %>%
  ggplot(aes(x=ind, y=coef, group=Effect, linetype=Effect, shape=Effect)) +
  {if(scn$OGM=="B")geom_point()} +
  geom_line() +
  facet_grid(~group, scales = "free_x") +
  scale_x_continuous("Variable index") +
  scale_y_continuous("Coefficient") +
  scale_linetype_manual(values = c(2,1)) +
  ggtitle(paste0("OGM ",scn$OGM)) +
  theme_bw() +
  theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5))
ggsave(file = here::here("output", "auxiliary",paste0("fig_coef_pop",scn$OGM,".tiff")),
       width = 2*100, height = 1*100, units = "mm", dpi = 350, compression = "lzw")
```

# Data analysis

In this section, the methods of analysis are presented below and the regression coefficients are displayed.

```{r}
# Prepare data
methnames <- c("oracle-OLS", "oracle-ridge", "lasso", "ridge", "lasso-ridge", "ridge-lasso", "ridge-garrote")
tbl_perf <- data.frame("model" = methnames,
                       R2 = NA, RMSPE = NA, MAE = NA, CS = NA, npeps = NA, extime=NA)
tbl_coef <-  true_beta %>% mutate(ind= as.numeric(str_remove_all(var, "V")))
tbl_pred <- data.frame("y" = data.obj.val$y)
beta_true <- c(true_beta$beta_X, true_beta$beta_D)

# Parameter
p <- scn$p

```

## Regression coefficients

### Oracle-OLS

```{r oOLS}
X <- cbind(data.obj$u, data.obj$d)
true_pred <- X[,which(beta_true!=0)]
fit.oracle <- lm(data.obj$y~true_pred)
beta_oracle <- rep(0, ncol(X)+1)
beta_oracle[c(1,which(beta_true!=0)+1)] <- coef(fit.oracle)
beta_oracle[is.na(beta_oracle)] <- 0 
tbl_pred$pred.oracle <-  beta_oracle[1] + c(cbind(data.obj.val$u, data.obj.val$d) %*% beta_oracle[-1])
tbl_perf[1, 2:5] <- eval_performance(pred = tbl_pred$pred.oracle, obs = tbl_pred$y)
tbl_perf[1, "npeps"] <- floor(sum(beta_oracle[2:(2*(p+1))]!=0, na.rm=TRUE)/2)
tbl_coef$beta_oracle_u <- beta_oracle[2:(p+1)]
tbl_coef$beta_oracle_d <- beta_oracle[(p+2):(2*p+1)]
fit.oracle$coefficients <- NULL
fit.oracle$coefficients <- beta_oracle
attr(fit.oracle, "class") <- "oracle"
attr(fit.oracle, "penalty") <- "-"
```

```{r}
tbl_coef %>%
  mutate(coefid = 1:nrow(.)) %>%
  pivot_longer(cols = c(beta_oracle_u, beta_oracle_d), names_to = "component",
               values_to = "coef") %>%
  mutate(component = toupper(str_sub(component, -1))) %>%
  ggplot(aes(x = coef, y = coefid, group = component, col = component)) +
  geom_point(shape = 1) +
  scale_x_continuous("Coefficient") +
  scale_y_continuous("Variable index") +
  geom_line(orientation = "y") +
  geom_vline(xintercept = 0, linetype = 2) +
  scale_color_manual("Component", values = c("grey20", "red3")) +
  theme_bw() +
  facet_grid(~component) +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "None")

```

### Oracle-ridge

```{r oridge}
# --- Oracle-ridge
X <- cbind(data.obj$u, data.obj$d)
true_pred_ind <- which(beta_true!=0)
data.obj.true <- list("y" = data_sim$data_ana$y, "x" = data.obj$x[,which(true_beta$beta_X!=0)], 
                      "u" = data.obj$u[,which(true_beta$beta_X!=0)], 
                      "d" = data.obj$d[,which(true_beta$beta_D!=0)], 
                      "clinical" = data.obj$clinical)    
fit.roracle <- perform_penreg(data.obj=data.obj.true, family = "gaussian",  alpha = 0, nl1 = nlams, cv = ncv, 
                              R = nR,  split_vars = TRUE, lmin.ratio = 0.000001)
tbl_pred$pred.roracle <- predict_penreg(obj = fit.roracle, newdata = data.obj.val, model = "roracle")
tbl_perf[2, 2:5] <- eval_performance(pred = tbl_pred$pred.roracle, obs = tbl_pred$y)
tbl_perf[2, "npeps"] <- fit.roracle$dfvars
tbl_perf[2, "extime"] <- fit.roracle$extime
beta_roracle <- rep(0,ncol(X)+1)
beta_roracle[c(1, true_pred_ind+1)] <- fit.roracle$coefficients
beta_roracle[is.na(beta_roracle)] <- 0 
fit.roracle$coefficients <- NULL
fit.roracle$coefficients <- beta_roracle
tbl_coef$beta_roracle_u <- beta_roracle[2:(p+1)]
tbl_coef$beta_roracle_d <- beta_roracle[(p+2):(2*p+1)]
attr(fit.roracle, "class") <- "oracle-ridge"
```

```{r}
cvmse <- melt(fit.roracle$cv.pred.err)
cvsd <- melt(fit.roracle$cv.pred.sd)
cvmmat <- merge(cvmse, cvsd, by=c("Var1", "Var2"))
colnames(cvmmat) <- c("R", "lambda", "cverr", "cvsd")
cvmmat$cverr.lo <- cvmmat$cverr - 1.96 * cvmmat$cvsd
cvmmat$cverr.up <- cvmmat$cverr + 1.96 * cvmmat$cvsd
cvmmat$R <- to_factor(cvmmat$R)
lambda_min <- fit.roracle$fit$lambda.min

ggplot(cvmmat, aes(x=log(lambda), y=cverr, col=R)) +
  geom_point() +
  geom_pointrange(aes(ymin=cverr.lo, ymax=cverr.up)) +
  geom_vline(xintercept = log(lambda_min), col="red", linetype="dashed") +
  scale_y_continuous("Cross-validated mean squared error")+
  scale_x_continuous("Log(λ)")+
  theme_bw() 
```

```{r}
tbl_coef %>%
  mutate(coefid = 1:nrow(.)) %>%
  pivot_longer(cols = c(beta_roracle_u, beta_roracle_d), names_to = "component",
               values_to = "coef") %>%
  mutate(component = toupper(str_sub(component, -1))) %>%
  ggplot(aes(x = coef, y = coefid, group = component, col = component)) +
  geom_point(shape = 1) +
  scale_x_continuous("Coefficient") +
  scale_y_continuous("Variable index") +
  geom_line(orientation = "y") +
  geom_vline(xintercept = 0, linetype = 2) +
  scale_color_manual("Component", values = c("grey20", "red3")) +
  theme_bw() +
  facet_grid(~component) +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "None")

```

### Lasso

```{r lasso}
# --- Lasso
fit.lasso <- perform_penreg(data.obj, family = "gaussian", alpha1 = 1,
                            nl1 = nlams, cv = ncv, R = nR, lmin.ratio = 0.000001)
tbl_pred$pred.lasso <- predict_penreg(obj = fit.lasso, 
                                      newdata = data.obj.val, model = "lasso")
tbl_perf[3, 2:5] <- eval_performance(pred = tbl_pred$pred.lasso, 
                                     obs = tbl_pred$y)
tbl_perf[3, "npeps"] <- fit.lasso$dfvars
tbl_perf[3, "extime"] <- fit.lasso$extime
tbl_coef$beta_lasso <- fit.lasso$coefficients[-1]
```

```{r}
cvmse <- melt(fit.lasso$cv.pred.err)
cvsd <- melt(fit.lasso$cv.pred.sd)
cvmmat <- merge(cvmse, cvsd, by=c("Var1", "Var2"))
colnames(cvmmat) <- c("R", "lambda", "cverr", "cvsd")
cvmmat$cverr.lo <- cvmmat$cverr - 1.96 * cvmmat$cvsd
cvmmat$cverr.up <- cvmmat$cverr + 1.96 * cvmmat$cvsd
cvmmat$R <- to_factor(cvmmat$R)
lambda_min <- fit.lasso$fit$lambda.min

ggplot(cvmmat, aes(x=log(lambda), y=cverr, col=R)) +
  geom_point() +
  geom_pointrange(aes(ymin=cverr.lo, ymax=cverr.up)) +
  geom_vline(xintercept = log(lambda_min), col="red", linetype="dashed") +
  scale_y_continuous("Cross-validated mean squared error")+
  scale_x_continuous("Log(λ)")+
  theme_bw() 
```

```{r}
#| label: fig-lassocoef 
#| fig-cap: "Coefficients of the lasso regression model ordered by the magnitude." 
tbl_coef %>%
  ggplot(aes(x = beta_lasso, y = ind)) +
  geom_point(shape = 1, col = "royalblue3") +
  scale_x_continuous("Coefficient") +
  scale_y_continuous("Variable index") +
  geom_line(orientation = "y",col = "royalblue3") +
  geom_vline(xintercept = 0, linetype = 2) +
  ggtitle("Unordered") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5))
```

### Ridge

```{r ridge}
# --- Ridge 
fit.ridge <- perform_penreg(data.obj, family = "gaussian",  alpha = 0, 
                               nl1 = nlams, cv = ncv, R = nR, 
                               split_vars = TRUE, lmin.ratio = 0.000001)
tbl_pred$pred.ridge <- predict_penreg(obj = fit.ridge, newdata = data.obj.val, model = "ridge")
tbl_perf[4, 2:5] <- eval_performance(pred = tbl_pred$pred.ridge, obs = tbl_pred$y)
tbl_perf[4, "npeps"] <- fit.ridge$dfvars
tbl_perf[4, "extime"] <- fit.ridge$extime
tbl_coef$beta_ridge_u <- fit.ridge$coefficients[2:(p+1)]
tbl_coef$beta_ridge_d <- fit.ridge$coefficients[(p+2):(2*p+1)]
```

```{r}
cvmse <- melt(fit.ridge$cv.pred.err)
cvsd <- melt(fit.ridge$cv.pred.sd)
cvmmat <- merge(cvmse, cvsd, by=c("Var1", "Var2"))
colnames(cvmmat) <- c("R", "lambda", "cverr", "cvsd")
cvmmat$cverr.lo <- cvmmat$cverr - 1.96 * cvmmat$cvsd
cvmmat$cverr.up <- cvmmat$cverr + 1.96 * cvmmat$cvsd
cvmmat$R <- to_factor(cvmmat$R)
lambda_min <- fit.ridge$fit$lambda.min

ggplot(cvmmat, aes(x=log(lambda), y=cverr, col=R)) +
  geom_point() +
  geom_pointrange(aes(ymin=cverr.lo, ymax=cverr.up)) +
  geom_vline(xintercept = log(lambda_min), col="red", linetype="dashed") +
  scale_y_continuous("Cross-validated mean squared error")+
  scale_x_continuous("Log(λ)")+
  theme_bw() 
```

```{r}
#| label: fig-ridgecoefcb 
#| fig-cap: "Component-specific coefficients of the ridge regression model by D and U, respectively." 
tbl_coef %>%
  mutate(coefid = 1:nrow(.)) %>%
  pivot_longer(cols = c(beta_ridge_u, beta_ridge_d), names_to = "component",
               values_to = "coef") %>%
  mutate(component = toupper(str_sub(component, -1))) %>%
  ggplot(aes(x = coef, y = coefid, group = component, col = component)) +
  geom_point(shape = 1) +
  scale_x_continuous("Coefficient") +
  scale_y_continuous("Variable index") +
  geom_line(orientation = "y") +
  geom_vline(xintercept = 0, linetype = 2) +
  scale_color_manual("Component", values = c("grey20", "red3")) +
  theme_bw() +
  facet_grid(~component) +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "None")

```

### Lasso-ridge

```{r lridge}
# --- Lasso-ridge 
fit.lridge <- perform_lridge(data.obj, family = "gaussian", cv = ncv, R = nR, nlambda = rep(nlams, 2), 
                             split_vars = TRUE, lmin.ratio = 0.000001)
tbl_pred$pred.lridge <- predict_lridge(obj = fit.lridge, newdata = data.obj.val)
tbl_perf[5, 2:5] <- eval_performance(pred = tbl_pred$pred.lridge, obs = tbl_pred$y)
tbl_perf[5, "npeps"] <- fit.lridge$dfvars
tbl_perf[5, "extime"] <- fit.lridge$extime
tbl_coef$beta_lridge_u <- fit.lridge$coefficients[2:(p+1)]
tbl_coef$beta_lridge_d <- fit.lridge$coefficients[(p+2):(2*p+1)]
```

```{r}
prederr <- fit.lridge$cv.pred.err
df  <- melt(prederr, value.name = "cv.mse") %>%
  `colnames<-`(c("lambda1", "lambda2", "cv.mse")) %>%
  filter(lambda1 != 1) # first lambda only intercept available
ind_lambda_min <- data.frame("lambda1"=fit.lridge$fit$index.lambda.min[1],
                             "lambda2"=fit.lridge$fit$index.lambda.min[2])
                             

ggplot(df) +
  geom_raster(aes(x = lambda1, y = lambda2, fill = cv.mse) ) +
  scale_x_continuous("Index of lambda1", breaks = seq(1,nlams,1)) +
  scale_y_continuous("Index of lambda2", breaks = seq(1,nlams,1)) +
  scale_fill_gradient2(low = "white", high = "blue") +
  geom_rect(data=ind_lambda_min, size=1, fill=NA, colour="black",
            aes(xmin=lambda1 - 0.5, xmax=lambda1 + 0.5, ymin=lambda2 - 0.5, ymax=lambda2 + 0.5)) +
  theme_bw()
```

```{r}
#| label: fig-lridgecoefcb 
#| fig-cap: "Component-specific coefficients of the lasso-ridge regression model by D and U, respectively." 
 
tbl_coef %>%
  mutate(coefid = 1:nrow(.)) %>%
  pivot_longer(cols = c(beta_lridge_u, beta_lridge_d), names_to = "component",
               values_to = "coef") %>%
  mutate(component = toupper(str_sub(component, -1))) %>%
  ggplot(aes(x = coef, y = coefid, group = component, col = component)) +
  geom_point(shape = 1) +
  scale_x_continuous("Coefficient") +
  scale_y_continuous("Variable index") +
  geom_line(orientation = "y") +
  geom_vline(xintercept = 0, linetype = 2) +
  scale_color_manual("Component", values = c("grey20", "red3")) +
  theme_bw() +
  facet_grid(~component) +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "None")

```

### Ridge-lasso

```{r rlasso}
# --- Ridge-lasso 
fit.rlasso <- perform_rlasso(data.obj, family = "gaussian", cv = ncv, 
                                R = nR, nlambda = rep(nlams, 2), 
                                split_vars = TRUE, lmin.ratio = 0.000001)
tbl_pred$pred.rlasso <- predict_rlasso(obj = fit.rlasso, newdata = data.obj.val)
tbl_perf[6, 2:5] <- eval_performance(pred = tbl_pred$pred.rlasso, obs = tbl_pred$y)
tbl_perf[6, "npeps"] <- fit.rlasso$dfvars
tbl_perf[6, "extime"] <- fit.rlasso$extime
tbl_coef$beta_rlasso_u <- fit.rlasso$coefficients[2:(p+1)]
tbl_coef$beta_rlasso_d <- fit.rlasso$coefficients[(p+2):(2*p+1)]
```

```{r}
prederr <- fit.rlasso$cv.pred.err
df  <- melt(prederr, value.name = "cv.mse") %>%
  `colnames<-`(c("lambda1", "lambda2", "cv.mse")) 
ind_lambda_min <- data.frame("lambda1"=fit.rlasso$fit$index.lambda.min[1],
                             "lambda2"=fit.rlasso$fit$index.lambda.min[2])
                             

ggplot(df) +
  geom_raster(aes(x = lambda1, y = lambda2, fill = cv.mse) ) +
  scale_x_continuous("Index of lambda1", breaks = seq(1,nlams,1)) +
  scale_y_continuous("Index of lambda2", breaks = seq(1,nlams,1)) +
  scale_fill_gradient2(low = "white", high = "blue") +
  geom_rect(data=ind_lambda_min, size=1, fill=NA, colour="black",
            aes(xmin=lambda1 - 0.5, xmax=lambda1 + 0.5, ymin=lambda2 - 0.5, ymax=lambda2 + 0.5)) +
  theme_bw()
```

```{r}
#| label: fig-rlassocoefcb 
#| fig-cap: "Component-specific coefficients of the ridge-lasso regression model by D and U, respectively." 
 
tbl_coef %>%
  mutate(coefid = 1:nrow(.)) %>%
  pivot_longer(cols = c(beta_rlasso_u, beta_rlasso_d), names_to = "component",
               values_to = "coef") %>%
  mutate(component = toupper(str_sub(component, -1))) %>%
  ggplot(aes(x = coef, y = coefid, group = component, col = component)) +
  geom_point(shape = 1) +
  scale_x_continuous("Coefficient") +
  scale_y_continuous("Variable index") +
  geom_line(orientation = "y") +
  geom_vline(xintercept = 0, linetype = 2) +
  scale_color_manual("Component", values = c("grey20", "red3")) +
  theme_bw() +
  facet_grid(~component) +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "None")

```

### Ridge-garrote

```{r rgarrote}
# --- Ridge-garrote
fit.rgarrote <- perform_rgarrote(data.obj, family = "gaussian", cv = ncv, R = nR, nlambda = rep(nlams, 2), 
                                 split_vars = TRUE, lmin.ratio = 0.000001)
tbl_pred$pred.rgarrote <- predict_rgarrote(obj = fit.rgarrote, newdata = data.obj.val)
tbl_perf[7, 2:5] <- eval_performance(pred = tbl_pred$pred.rgarrote, obs = tbl_pred$y)
tbl_perf[7, "npeps"] <- fit.rgarrote$dfvars
tbl_perf[7, "extime"] <- fit.rgarrote$extime
tbl_coef$beta_rgarrote_u <- fit.rgarrote$coefficients[2:(p+1)]
tbl_coef$beta_rgarrote_d <- fit.rgarrote$coefficients[(p+2):(2*p+1)]
```

```{r}
prederr <- fit.rgarrote$cv.pred.err
df  <- melt(prederr, value.name = "cv.mse") %>%
  `colnames<-`(c("lambda1", "lambda2", "cv.mse")) %>%
  filter(lambda1 != 1)
ind_lambda_min <- data.frame("lambda1"=fit.rgarrote$fit$index.lambda.min[1],
                             "lambda2"=fit.rgarrote$fit$index.lambda.min[2])
                             

ggplot(df) +
  geom_raster(aes(x = lambda1, y = lambda2, fill = cv.mse) ) +
  scale_x_continuous("Index of lambda1", breaks = seq(1,nlams,1)) +
  scale_y_continuous("Index of lambda2", breaks = seq(1,nlams,1)) +
  scale_fill_gradient2(low = "white", high = "blue") +
  geom_rect(data=ind_lambda_min, size=1, fill=NA, colour="black",
            aes(xmin=lambda1 - 0.5, xmax=lambda1 + 0.5, ymin=lambda2 - 0.5, ymax=lambda2 + 0.5)) +
  theme_bw()
```

```{r}
#| label: fig-rgarrotecoefcb 
#| fig-cap: "Component-specific coefficients of the ridge-garrote regression model by D and U, respectively." 
 
tbl_coef %>%
  mutate(coefid = 1:nrow(.)) %>%
  pivot_longer(cols = c(beta_rgarrote_u, beta_rgarrote_d), 
               names_to = "component",
               values_to = "coef") %>%
  mutate(component = toupper(str_sub(component, -1))) %>%
  ggplot(aes(x = coef, y = coefid, group = component, col = component)) +
  geom_point(shape = 1) +
  scale_x_continuous("Coefficient") +
  scale_y_continuous("Variable index") +
  geom_line(orientation = "y") +
  geom_vline(xintercept = 0, linetype = 2) +
  scale_color_manual("Component", values = c("grey20", "red3")) +
  theme_bw() +
  facet_grid(~component) +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "None")

```

## Variable selection

```{r}
# Variable selection
groupsize <- scn$p/ngroups
list_models <- list(fit.oracle,
                    fit.roracle,
                    fit.lasso, 
                    fit.ridge, 
                    fit.rlasso,
                    fit.lridge,
                    fit.rgarrote)
list_sel <- list()
for(l in 1:length(list_models)){
  fit.model <-  list_models[[l]]
  list_sel[[l]] <- eval_selection(model = attr(fit.model, "class"), varnames = tbl_coef$var,
                                  true_coef = true_beta, pred_coef = fit.model$coefficients, ngroups = ngroups, p = p)
}
tbl_varsel <- do.call(rbind, lapply(list_sel, function(x) x[[1]]))
tbl_groupsel <- do.call(rbind, lapply(list_sel, function(x) x[[2]])) 
tbl_allsel <- do.call(rbind, lapply(list_sel, function(x) x[[3]])) 
```

```{r}
tbl_allsel %>% mutate_at(2:5, round, 2) %>% gt()
```

## Calibration

```{r calibration}
pcal_oracle <- plot_calibration(pred = tbl_pred$pred.oracle, obs = tbl_pred$y, fig.title = "oracle-OLS")
pcal_roracle <- plot_calibration(pred = tbl_pred$pred.roracle, obs = tbl_pred$y, fig.title = "oracle-ridge")
pcal_lasso <- plot_calibration(pred = tbl_pred$pred.lasso, obs = tbl_pred$y, fig.title = "lasso")
pcal_ridge <- plot_calibration(pred = tbl_pred$pred.ridge, obs = tbl_pred$y, fig.title = "ridge")
pcal_lridge <- plot_calibration(pred = tbl_pred$pred.lridge, obs = tbl_pred$y, fig.title = "lasso-ridge")
pcal_rlasso <- plot_calibration(pred = tbl_pred$pred.rlasso, obs = tbl_pred$y, fig.title = "ridge-lasso")
pcal_rgarrote <- plot_calibration(pred = tbl_pred$pred.rgarrote, obs = tbl_pred$y, fig.title = "ridge-garrote")

(pcal_oracle + pcal_lasso + pcal_ridge) / (pcal_lridge + pcal_rlasso + pcal_rgarrote)
```

## Performance measures

```{r}
#| label: tbl-results
#| tbl-cap: "Results of all models"
tbl_perf %>%
  data.frame() %>%
  mutate(model=fct_relevel(model, c( "oracle-OLS","oracle-ridge", "lasso", "ridge", "lasso-ridge",
                                     "ridge-lasso", "ridge-garrote")),
         relRMSPE=RMSPE/min(RMSPE)) %>%
  relocate(relRMSPE, .after=RMSPE) %>%
  relocate(extime, .after=CS) %>%
  arrange(model) %>%
  mutate_at(3:8, round, digits = 3) %>%
  gt()
```

# Questions

The following questions are open
